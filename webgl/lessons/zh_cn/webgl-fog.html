<!DOCTYPE html>
<!-- this file is auto-generated from webgl/lessons/zh_cn/webgl-fog.md. Do not edited directly -->
<!--
Copyright 2012, Gregg Tavares.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

*   Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

*   Redistributions in binary form must reproduce the above
    copyright notice, this list of conditions and the following disclaimer
    in the documentation and/or other materials provided with the
    distribution.

*   Neither the name of Gregg Tavares. nor the names of his
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->
<html lang="zh-cn">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<meta property="og:title" content="WebGL 雾" />
<meta property="og:type" content="website" />
<meta property="og:image" content="http://webgl2fundamentals.org/webgl/lessons/resources/webgl2fundamentals.jpg" />
<meta property="og:description" content="怎样实现雾" />
<meta property="og:url" content="http://webgl2fundamentals.org/webgl/lessons/zh_cn/webgl-fog.html" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:site" content="@greggman" />
<meta name="twitter:creator" content="@greggman" />
<meta name="twitter:domain" content="webgl2fundamentals.org" />
<meta name="twitter:title" content="WebGL 雾" />
<meta name="twitter:url" content="http://webgl2fundamentals.org/webgl/lessons/zh_cn/webgl-fog.html" />
<meta name="twitter:description" content="怎样实现雾" />
<meta name="twitter:image:src" content="http://webgl2fundamentals.org/webgl/lessons/resources/webgl2fundamentals.jpg" />


<title>WebGL 雾</title>
<link href="/webgl/lessons/resources/webgl2fundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="stylesheet" href="/webgl/lessons/resources/lesson.css" type="text/css" />
</head>
<body>
<div class="webgl_navbar">
  <div>
    <select class="language">
    <option value="/webgl/lessons/webgl-fog.html" >English</a>
    <option value="/webgl/lessons/de/webgl-fog.html" >Deutsch</a>
    <option value="/webgl/lessons/ko/webgl-fog.html" >한국어</a>
    <option value="/webgl/lessons/pt-br/webgl-fog.html" >Português Brasileiro</a>
    <option value="/webgl/lessons/zh_cn/webgl-fog.html" selected>简体中文</a>
</select>


    <a href="#toc">目录</a>
  </div>
</div>
<div class="webgl_header">
  <h1><a href="/webgl/lessons/zh_cn/">WebGL2Fundamentals.org</a></h1>
</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGL 雾</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>这篇文章是WebGL系列文章的一部分。从<a href="webgl-fundamentals.html">基础概念</a>开始。</p>
<p>WebGL实现雾效果对我来说很有趣，因为当我思考它是如何实现时，会觉得它很<em>假</em>。基本上你所做的就是在着色器中使用某些从相机位置计算的深度或者距离来使颜色或多或少的成为雾色。</p>
<p>换句话说你从这样的基本公式开始</p>
<pre class="prettyprint"><code class="lang-glsl">outColor = mix(originalColor, fogColor, fogAmount);
</code></pre>
<p>其中<code>fogAmount</code>是0到1之间的值。<code>mix</code>函数混合前2个值。当<code>fogAmount</code>为0时，<code>mix</code>返回<code>originalColor</code>。当<code>fogAmount</code>为1时，<code>mix</code> 返回<code>fogColor</code>。在0到1之间时，你会获得两个颜色按百分比混合的颜色值。你可以像这样自己实现<code>mix</code> </p>
<pre class="prettyprint"><code class="lang-glsl">outColor = originalColor + (fogColor - originalColor) * fogAmount;
</code></pre>
<p>让我们来写一个这样的着色器。我们会使用<a href="webgl-3d-textures.html">纹理</a>文章中的纹理立方体。</p>
<p>让我们将混合函数添加到片断着色器</p>
<pre class="prettyprint"><code class="lang-glsl">#version 300 es
precision mediump float;

// 由顶点着色器传入。
in vec2 v_texcoord;

// 纹理。
uniform sampler2D u_texture;

+uniform vec4 u_fogColor;
+uniform float u_fogAmount;

out vec4 outColor;

void main() {
+  vec4 color = texture(u_texture, v_texcoord);
+  outColor = mix(color, u_fogColor, u_fogAmount);  
}
</code></pre>
<p>然后在初始化阶段，我们需要查找新的全局变量位置</p>
<pre class="prettyprint"><code class="lang-js">var fogColorLocation = gl.getUniformLocation(program, &quot;u_fogColor&quot;);
var fogAmountLocation = gl.getUniformLocation(program, &quot;u_fogAmount&quot;);
</code></pre>
<p>在渲染阶段设置他们</p>
<pre class="prettyprint"><code class="lang-js">var fogColor = [0.8, 0.9, 1, 1];
var settings = {
  fogAmount: .5,
};

...

function drawScene(time) {
  ...

  // 清除画布和深度缓冲区。
  // 用雾的颜色清除
  gl.clearColor(...fogColor);
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

  ...

  // 设置雾色和雾量
  gl.uniform4fv(fogColorLocation, fogColor);
  gl.uniform1f(fogAmountLocation, settings.fogAmount);

  ...
}
</code></pre>
<p>在这里你会看到如果拖动滑块，可以在纹理和雾色之间变化</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-3d-fog-just-mix.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-3d-fog-just-mix.html" target="_blank">点此在新窗口中浏览</a>
</div>

</p>
<p>所以现在我们真正需要做的是根据一些原则例如以相机为基准的深度来计算雾量代替传入雾量。</p>
<p>回想关于<a href="webgl-3d-camera.html">相机</a>的文章，在我们应用视图矩阵之后，所有位置转换为相对于相机的位置。相机看向-z轴，所以如果我们只看z位置，在乘以世界和视图矩阵之后，我们会得到一个值代表相较于相机所在z平面的距离。</p>
<p>让我们改变顶点着色器来传递那个数据给片断着色器，使我们能够用它来计算雾量。为此，我们将<code>u_matrix</code>分成两部分。一个投影矩阵和一个世界视图矩阵。</p>
<pre class="prettyprint"><code class="lang-glsl">#version 300 es
in vec4 a_position;
in vec2 a_texcoord;

-uniform mat4 u_matrix;
+uniform mat4 u_worldView;
+uniform mat4 u_projection;

out vec2 v_texcoord;
+out float v_fogDepth;

void main() {
  // 给位置乘以矩阵
-  gl_Position = u_matrix * a_position;
+  gl_Position = u_projection * u_worldView * a_position;

  // 传递纹理坐标给片断着色器
  v_texcoord = a_texcoord;

+  // 传递相对于相机的负z位置
+  // 相机看向-z方向，所以通常
+  // i在相机前面的物体会有一个负Z位置
+  // 取负我们得到一个正的深度
+  v_fogDepth = -(u_worldView * a_position).z;
}
</code></pre>
<p>现在在片断着色器中我们希望如果深度小于某些值，不融合雾色(fogAmount = 0)。如果深度大于某个值则为100%雾色(fogAmount = 1)。在两个值之间则融合颜色。</p>
<p>我们可以编写代码来实现这点，但GLSL有一个函数<code>smoothstep</code>就是这样做的。你给定最小值，最大值，和要测试的值。如果测试值小于等于最小值返回0。如果测试值大于等于最大值返回1。如果测试值在两值之间，则根据测试值在最小值和最大值之间的位置返回0到1之间的插值。</p>
<p>所以，在我们的片断着色器中使用它来计算雾量会是非常简单的。</p>
<pre class="prettyprint"><code class="lang-glsl">#version 300 es
precision mediump float;

// 从顶点着色器传入的。
in vec2 v_texcoord;
in float v_fogDepth;

// 纹理。
uniform sampler2D u_texture;
uniform vec4 u_fogColor;
-uniform float u_fogAmount;
+uniform float u_fogNear;
+uniform float u_fogFar;

out vec4 outColor;

void main() {
  vec4 color = texture(u_texture, v_texcoord);

+  float fogAmount = smoothstep(u_fogNear, u_fogFar, v_fogDepth);

-  outColor = mix(color, u_fogColor, u_fogAmount);  
+ outColor = mix(color, u_fogColor, fogAmount);  
}
</code></pre>
<p>当然我们需要在初始化阶段找到所有的全局变量</p>
<pre class="prettyprint"><code class="lang-js">// 查找全局变量
+var projectionLocation = gl.getUniformLocation(program, &quot;u_projection&quot;);
+var worldViewLocation = gl.getUniformLocation(program, &quot;u_worldView&quot;);
var textureLocation = gl.getUniformLocation(program, &quot;u_texture&quot;);
var fogColorLocation = gl.getUniformLocation(program, &quot;u_fogColor&quot;);
+var fogNearLocation = gl.getUniformLocation(program, &quot;u_fogNear&quot;);
+var fogFarLocation = gl.getUniformLocation(program, &quot;u_fogFar&quot;);
</code></pre>
<p>在渲染阶段设置他们</p>
<pre class="prettyprint"><code class="lang-js">var fogColor = [0.8, 0.9, 1, 1];
var settings = {
-  fogAmount: .5,
+  fogNear: 1.1,
+  fogFar: 2.0,
};

// 绘制场景
function drawScene(time) {
  ...

  // 计算投影矩阵
  var aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
  var projectionMatrix =
      m4.perspective(fieldOfViewRadians, aspect, 1, 2000);

  var cameraPosition = [0, 0, 2];
  var up = [0, 1, 0];
  var target = [0, 0, 0];

  // 使用look at函数计算相机矩阵
  var cameraMatrix = m4.lookAt(cameraPosition, target, up);

  // 由相机矩阵计算视图矩阵
  var viewMatrix = m4.inverse(cameraMatrix);

-  var viewProjectionMatrix = m4.multiply(projectionMatrix, viewMatrix);
-
-  var matrix = m4.xRotate(viewProjectionMatrix, modelXRotationRadians);
-  matrix = m4.yRotate(matrix, modelYRotationRadians);

+  var worldViewMatrix = m4.xRotate(viewMatrix, modelXRotationRadians);
+  worldViewMatrix = m4.yRotate(worldViewMatrix, modelYRotationRadians);

  // 设置矩阵
-  gl.uniformMatrix4fv(matrixLocation, false, matrix);
+  gl.uniformMatrix4fv(projectionLocation, false, projectionMatrix);
+  gl.uniformMatrix4fv(worldViewLocation, false, worldViewMatrix);

  // 告诉着色器对于u_texture使用纹理单元0
  gl.uniform1i(textureLocation, 0);

  // 设置雾颜色和最近值，最远值
  gl.uniform4fv(fogColorLocation, fogColor);
+  gl.uniform1f(fogNearLocation, settings.fogNear);
+  gl.uniform1f(fogFarLocation, settings.fogFar);
-  gl.uniform1f(fogAmountLocation, settings.fogAmount);
</code></pre>
<p>我们绘制了40个立方体在不同的距离上，以便更容易看到雾效果。</p>
<pre class="prettyprint"><code class="lang-js">var settings = {
  fogNear: 1.1,
  fogFar: 2.0,
+  xOff: 1.1,
+  zOff: 1.4,
};

...

const numCubes = 40;
for (let i = 0; i &lt;= numCubes; ++i) {
  var worldViewMatrix = m4.translate(viewMatrix, -2 + i * settings.xOff, 0, -i * settings.zOff);
  worldViewMatrix = m4.xRotate(worldViewMatrix, modelXRotationRadians + i * 0.1);
  worldViewMatrix = m4.yRotate(worldViewMatrix, modelYRotationRadians + i * 0.1);

  gl.uniformMatrix4fv(worldViewLocation, false, worldViewMatrix);

  // 绘制几何体
  gl.drawArrays(gl.TRIANGLES, 0, 6 * 6);
}
</code></pre>
<p>现在我们得到了基于深度的雾</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-3d-fog-depth-based.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-3d-fog-depth-based.html" target="_blank">点此在新窗口中浏览</a>
</div>

</p>
<p>注意：我们没有添加任何代码来确保<code>fogNear</code>小于等于<code>fogFar</code>，这可能是无效的设置，所以确保设定它们为合适的值。</p>
<p>正如上面提到的，对我来说这像一个诡计。它看起来像雾因为雾色和背景色相同。改变背景色，幻觉消失了。</p>
<pre class="prettyprint"><code class="lang-js">-gl.clearColor(...fogColor);
+gl.clearColor(1, 0, 0, 1);  // red
</code></pre>
<p>得到</p>
<div class="webgl_center"><img src="../resources/fog-background-color-mismatch.png"></div>

<p>所以请记住，你需要设置背景颜色匹配雾色。</p>
<p>使用深度很简单但是有一个问题。假设围绕相机有一圈物体。我们根据到相机z平面的距离计算雾量。这意味着你转动相机，当它在视图空间中的z值趋近于0，物体会越来越不受雾的影响。</p>
<div class="webgl_center"><img src="../resources/fog-depth.svg" style="width: 600px;"></div>

<p>在这个例子中你会看到问题</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-3d-fog-depth-based-issue.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-3d-fog-depth-based-issue.html" target="_blank">点此在新窗口中浏览</a>
</div>

</p>
<p>上面有8个立方体在相机为中心的圆环上。相机在它的位置旋转。这意味着立方体总是距相机相同的距离，但是距离Z平面不同的距离。所以我们的雾量计算方法会导致边缘附近的立方体会从雾中出来。</p>
<p>修复方法是用计算到相机的距离代替，这对于所有的立方体都是相同的。</p>
<div class="webgl_center"><img src="../resources/fog-distance.svg" style="width: 600px;"></div>

<p>为此，我们只需将视图空间中的顶点位置从顶点着色器传递到片断着色器</p>
<pre class="prettyprint"><code class="lang-glsl">#version 300 es
in vec4 a_position;
in vec2 a_texcoord;

uniform mat4 u_worldView;
uniform mat4 u_projection;

out vec2 v_texcoord;
-out float v_fogDepth;
+out vec3 v_position;

void main() {
  // 给位置乘以矩阵。
  gl_Position = u_projection * u_worldView * a_position;

  // 传递纹理坐标给片断着色器。
  v_texcoord = a_texcoord;

-  // 传递相对于相机的负z位置
-  // 相机看向-z方向，所以通常
-  // 在相机前面的物体会有一个负Z位置
-  // 取负我们得到一个正的深度
-  v_fogDepth = -(u_worldView * a_position).z;
+  // 传递视图位置给片断着色器
+  v_position = (u_worldView * a_position).xyz;
}
</code></pre>
<p>然后在片断着色器中我们可以使用位置来计算距离</p>
<pre class="prettyprint"><code>#version 300 es
precision mediump float;

// 从顶点着色器传入
in vec2 v_texcoord;
-in float v_fogDepth;
+in vec3 v_position;

// 纹理。
uniform sampler2D u_texture;
uniform vec4 u_fogColor;
uniform float u_fogNear;
uniform float u_fogFar;

out vec4 outColor;

void main() {
  vec4 color = texture(u_texture, v_texcoord);

-  float fogAmount = smoothstep(u_fogNear, u_fogFar, v_fogDepth);
+  float fogDistance = length(v_position);
+  float fogAmount = smoothstep(u_fogNear, u_fogFar, fogDistance);

  outColor = mix(color, u_fogColor, fogAmount);  
}
</code></pre><p>现在，当相机转动时，立方体不再从雾中出来</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-3d-fog-distance-based.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-3d-fog-distance-based.html" target="_blank">点此在新窗口中浏览</a>
</div>

</p>
<p>到目前为止，我们所有的雾都使用了线性计算。换句话说，在最近处到最远处之间雾颜色被线性地施加。像现实中的许多事物一样，雾是指数方式显现的。它根据距观察者距离的平方变厚。一个常见的指数雾公式是</p>
<pre class="prettyprint"><code class="lang-glsl">#define LOG2 1.442695

fogAmount = 1. - exp2(-fogDensity * fogDensity * fogDistance * fogDistance * LOG2));
fogAmount = clamp(fogAmount, 0., 1.);
</code></pre>
<p>要使用它，我们将片断着色器改成这样</p>
<pre class="prettyprint"><code class="lang-glsl">#version 300 es
precision mediump float;

// 从顶点着色器传入。
in vec2 v_texcoord;
in vec3 v_position;

// 纹理。
uniform sampler2D u_texture;
uniform vec4 u_fogColor;
-uniform float u_fogNear;
-uniform float u_fogFar;
+uniform float u_fogDensity;

out vec4 outColor;

void main() {
  vec4 color = texture(u_texture, v_texcoord);

  #define LOG2 1.442695

  float fogDistance = length(v_position);
-  float fogAmount = smoothstep(u_fogNear, u_fogFar, fogDistance);
+  float fogAmount = 1. - exp2(-u_fogDensity * u_fogDensity * fogDistance * fogDistance * LOG2);
  fogAmount = clamp(fogAmount, 0., 1.);

  outColor = mix(color, u_fogColor, fogAmount);  
}
</code></pre>
<p>我们得到了距离<em>exp2</em>基于密度的雾</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-3d-fog-distance-exp2.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-3d-fog-distance-exp2.html" target="_blank">点此在新窗口中浏览</a>
</div>

</p>
<p>需要注意的是基于密度的雾没有最近值和最远值设置。它可能更符合真实情况但也可能不符合你的审美需求。你更喜欢哪一个是一个艺术问题。</p>
<p>还有很多其他计算雾的方法。在低性能GPU上，你可能只使用<code>gl_FragCoord.z</code>。<code>gl_FragCoord</code>是WebGL内置的全局变量。<code>x</code>和<code>y</code>分量是被绘制像素的坐标。<code>z</code>坐标是像素的深度，范围从0到1。虽然不能直接转换到距离，但你仍然可以选取从0到1的某些值作为最近值和最远值来获得看起来像雾的效果。没有需要从顶点着色器传递到片断着色器的值，也不需要距离计算，所以这是一个在低性能GPU上节省的方法。</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-3d-fog-depth-based-gl_FragCoord.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-3d-fog-depth-based-gl_FragCoord.html" target="_blank">点此在新窗口中浏览</a>
</div>

</p>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgl/lessons/webgl-fog.html" >English</a>
    <option value="/webgl/lessons/de/webgl-fog.html" >Deutsch</a>
    <option value="/webgl/lessons/ko/webgl-fog.html" >한국어</a>
    <option value="/webgl/lessons/pt-br/webgl-fog.html" >Português Brasileiro</a>
    <option value="/webgl/lessons/zh_cn/webgl-fog.html" selected>简体中文</a>
</select>


        <div id="toc">
          <ul>  <li>基础概念</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-getting-webgl2.html">怎样使用WebGL2</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-fundamentals.html">WebGL2 Fundamentals</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-how-it-works.html">WebGL2 How It Works</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-shaders-and-glsl.html">WebGL2 Shaders and GLSL</a></li>
        </ul>
  <li>WebGL2 vs WebGL1</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl2-whats-new.html">WebGL2有什么新内容</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl1-to-webgl2.html">迁移WebGL1到WebGL2</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl1-to-webgl2-fundamentals.html">WebGLFundamentals.org和WebGL2Fundamentals.org的区别</a></li>
        </ul>
  <li>Image Processing</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-image-processing.html">WebGL2 Image Processing</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-image-processing-continued.html">WebGL2 Image Processing Continued</a></li>
        </ul>
  <li>2D translation, rotation, scale, matrix math</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-2d-translation.html">WebGL2 2D Translation</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-2d-rotation.html">WebGL2 2D Rotation</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-2d-scale.html">WebGL2 2D Scale</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-2d-matrices.html">WebGL2 2D Matrices</a></li>
        </ul>
  <li>三维</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-3d-orthographic.html">WebGL2 - Orthographic 3D</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-3d-perspective.html">WebGL2 3D Perspective</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-3d-camera.html">WebGL2 3D - Cameras</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-matrix-naming.html">WebGL2三维矩阵命名</a></li>
        </ul>
  <li>Lighting</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-3d-lighting-directional.html">WebGL2 3D - Directional Lighting</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-3d-lighting-point.html">WebGL2 3D - Point Lighting</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-3d-lighting-spot.html">WebGL2 3D - Spot Lighting</a></li>
        </ul>
  <li>Structure and Organization</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-less-code-more-fun.html">WebGL2 - Less Code, More Fun</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-drawing-multiple-things.html">WebGL2 - Drawing Multiple Things</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-scene-graph.html">WebGL2 - Scene Graphs</a></li>
        </ul>
  <li>Geometry</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-3d-geometry-lathe.html">WebGL2 3D Geometry - Lathe</a></li>
        </ul>
  <li>Textures</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-3d-textures.html">WebGL2 3D - Textures</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-data-textures.html">WebGL2 - Data Textures</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-2-textures.html">WebGL2 - Using 2 or More Textures</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-cors-permission.html">WebGL2 - Cross Origin Images</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-3d-perspective-correct-texturemapping.html">WebGL2 3D - Perspective Correct Texture Mapping</a></li>
        </ul>
  <li>Rendering To A Texture</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-render-to-texture.html">WebGL2 - Render to Texture</a></li>
        </ul>
  <li>技术</li>
        <ul>
          <ul>  <li>2D</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-2d-drawimage.html">WebGL2 2D - DrawImage</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-2d-matrix-stack.html">WebGL2 2D - Matrix Stack</a></li>
        </ul>
  <li>三维</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-cube-maps.html">WebGL2 立方体贴图</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-environment-maps.html">WebGL2 环境贴图</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-skybox.html">WebGL2 天空盒</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-skinning.html">WebGL2 蒙皮</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-fog.html">WebGL2 雾</a></li>
        </ul>
  <li>Text</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-text-html.html">WebGL2 Text - HTML</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-text-canvas2d.html">WebGL2 Text - Canvas 2D</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-text-texture.html">WebGL2 Text - Using a Texture</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-text-glyphs.html">WebGL2 Text - Using a Glyph Texture</a></li>
        </ul></ul>
        </ul>
  <li>Tips</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-smallest-programs.html">WebGL2 Smallest Programs</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-drawing-without-data.html">WebGL2 Drawing Without Data</a></li>
        </ul>
  <li>Misc</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-setup-and-installation.html">WebGL2 Setup And Installation</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-boilerplate.html">WebGL2 Boilerplate</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-resizing-the-canvas.html">WebGL2 Resizing the Canvas</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-animation.html">WebGL2 - Animation</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-and-alpha.html">WebGL2 and Alpha</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-2d-vs-3d-library.html">WebGL2 - 2D vs 3D libraries</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-anti-patterns.html">WebGL2 - Anti-Patterns</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-matrix-vs-math.html">WebGL Matrices vs Math Matrices</a></li>
        </ul>
  <li>Reference</li>
        <ul>
          <li><a href="/webgl/lessons/zh_cn/webgl-attributes.html">WebGL2 Attributes</a></li>
<li><a href="/webgl/lessons/zh_cn/webgl-texture-units.html">WebGL2 Texture Units</a></li>
        </ul></ul>
<ul>
  <li><a href="/docs/">API帮助文档</a></li>
  <li><a href="http://twgljs.org">TWGL，一个轻量级WebGL辅助库</a></li>
  <li><a href="https://github.com/gfxfundamentals/webgl2-fundamentals">GitHub</a></li>
</ul>
        </div>
    </div>
    <div class="lesson-comments">
        <div>有关于WebGL2的疑问? <a href="http://stackoverflow.com/questions/tagged/webgl2">在Stackoverflow提问</a>.</div>
        <div>有意见或建议? <a href="http://github.com/gfxfundamentals/webgl2-fundamentals/issues">在GitHub上提issue</a>.</div>

        <div id="disqus_thread"></div>
        <script type="text/javascript">
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'webgl2fundamentals'; // required: replace example with your forum shortname
            var disqus_identifier = 'WebGL 雾';
            var disqus_title = 'WebGL 雾';

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function() {
                if (window.location.hostname.indexOf("webgl2fundamentals.org") < 0) {
                    return;
                }
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>
</body>
<script src="/3rdparty/jquery-1.11.2.min.js"></script>
<script src="/webgl/lessons/resources/prettify.js"></script>
<script src="/webgl/lessons/resources/lesson.js"></script>
<script src="//cdn.webglstats.com/stat.js" defer="defer" async="async"></script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-90754717-1', 'auto');
  ga('send', 'pageview');

</script>


</html>



