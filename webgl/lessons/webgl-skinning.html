<!DOCTYPE html>
<!-- this file is auto-generated from webgl/lessons/webgl-skinning.md. Do not edited directly -->
<!--
Copyright 2012, Gregg Tavares.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

*   Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

*   Redistributions in binary form must reproduce the above
    copyright notice, this list of conditions and the following disclaimer
    in the documentation and/or other materials provided with the
    distribution.

*   Neither the name of Gregg Tavares. nor the names of his
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<meta property="og:title" content="WebGL Skinning" />
<meta property="og:type" content="website" />
<meta property="og:image" content="http://webgl2fundamentals.org/webgl/lessons/resources/webgl2fundamentals.jpg" />
<meta property="og:description" content="How to skin a mesh in WebGL" />
<meta property="og:url" content="http://webgl2fundamentals.org/webgl/lessons/webgl-skinning.html" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:site" content="@greggman" />
<meta name="twitter:creator" content="@greggman" />
<meta name="twitter:domain" content="webgl2fundamentals.org" />
<meta name="twitter:title" content="WebGL Skinning" />
<meta name="twitter:url" content="http://webgl2fundamentals.org/webgl/lessons/webgl-skinning.html" />
<meta name="twitter:description" content="How to skin a mesh in WebGL" />
<meta name="twitter:image:src" content="http://webgl2fundamentals.org/webgl/lessons/resources/webgl2fundamentals.jpg" />


<title>WebGL Skinning</title>
<link href="/webgl/lessons/resources/webgl2fundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="stylesheet" href="/webgl/lessons/resources/lesson.css" type="text/css" />
</head>
<body>
<div class="webgl_navbar">
  <div>
    <select class="language">
    <option value="/webgl/lessons/webgl-skinning.html" selected>English</a>
    <option value="/webgl/lessons/de/webgl-skinning.html" >Deutsch</a>
    <option value="/webgl/lessons/ko/webgl-skinning.html" >한국어</a>
    <option value="/webgl/lessons/pt-br/webgl-skinning.html" >Português Brasileiro</a>
</select>


    <a href="#toc">Table of Contents</a>
  </div>
</div>
<div class="webgl_header">
  <h1><a href="/">WebGL2Fundamentals.org</a></h1>
</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGL Skinning</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>Skinning in graphics is the name given to moving a set of vertices based
on the weighted influence of multiple matrices. That&#39;s pretty abstract.</p>
<p>It&#39;s called <em>skinning</em> because it&#39;s typically used to make 3D characters
have a &quot;skeleton&quot; made from &quot;bones&quot; where &quot;bone&quot; is another name for matrix
and then <strong>per vertex</strong> setting the influence of each bone to that vertex.</p>
<p>So for example the hand bone would have nearly 100% influence on the vertices
near the hand of a character where as the foot bone would have zero influence
on those same vertices.</p>
<p>The basic part is that you need bones (which is just a fancy way of saying
a matrix hierarchy) and weights.  Weights are per vertex values that go
from 0 to 1 to say how much a particular bone-matrix affects the position
of that vertex.  Weights are kind of like vertex colors as far as data.
One set of weights per vertex.  In other words the weights are put in a
buffer and provided through attributes.</p>
<p>Typically you limit the number of weights per vertex partly because
otherwise it would be way too much data.  A character can have anywhere
from 15 bones (Virtua Fighter 1) to 150-300 bones (some modern games).
If you had 300 bones you&#39;d need 300 weights PER vertex PER bone.  If your
character had 10000 vertices that would be 3 million weights needed.</p>
<p>So, instead most realtime skinning systems limit it ~4 weights per vertex.
Usually this is accomplished in an exporter/converter that takes data from
a 3D packages like blender/maya/3dsmax and for each vertex finds the 4
bones with the highest weights and then normalizes those weights</p>
<p>To give an pseudo example a non-skinned vertex is typically computed like this</p>
<pre><code>gl_Position = projection * view * model * position;
</code></pre><p>A skinned vertex is effectively computed like this</p>
<pre><code>gl_Position = projection * view *
              (bone1Matrix * position * weight1 +
               bone2Matrix * position * weight2 +
               bone3Matrix * position * weight3 +
               bone4Matrix * position * weight4);
</code></pre><p>Assuming you stored the bones matrices in a uniform array, and you
passed in the the weights and which bone each weight applies to as
attributes you might do something like</p>
<pre><code>in vec4 a_position;
in vec4 a_weights;         // 4 weights per vertex
in uvec4 a_boneNdx;        // 4 bone indices per vertex
uniform mat4 bones[MAX_BONES];  // 1 matrix per bone

gl_Position = projection * view *
              (a_bones[a_boneNdx[0]] * a_position * a_weight[0] +
               a_bones[a_boneNdx[1]] * a_position * a_weight[1] +
               a_bones[a_boneNdx[2]] * a_position * a_weight[2] +
               a_boneS[a_boneNdx[3]] * a_position * a_weight[3]);
</code></pre><p>There&#39;s one more issue.  Let&#39;s say you have a model of a person with
the origin (0,0,0) on the floor just between their feet.</p>
<div class="webgl_center"><img src="resources/bone-head.svg" style="width: 500px;"></div>

<p>Now imagine you put a matrix/bone/joint at their head and you want to use
that for bone for skinning.  To keep it simple imagine you just set the
weights so the the vertices of the head have a weight of 1.0 for the head
bone and no other joints influence those vertices.  </p>
<div class="webgl_center"><img src="resources/bone-head-setup.svg" style="width: 500px;"></div>

<p>There&#39;s a problem.
The head vertices are 2 units above the origin.  The head bone is also 2
units above the origin.  If you actually multiplied those head vertices by
the head bone matrix you&#39;d get vertices 4 units above the origin.  The
original 2 units of the vertices + the 2 units of the head bone matrix.</p>
<div class="webgl_center"><img src="resources/bone-head-problem.svg" style="width: 500px;"></div>

<p>A solution is to store a &quot;bind pose&quot; which is an extra matrix per joint of
where each matrix was before you used it to influence the vertices.  In that
case the bind pose of the head matrix would be 2 units above the origin.
So now you can use the inverse of that matrix to subtract out the extra 2
units.</p>
<p>In other words the bone matrices passed to the shader have each been
multiplied by their inverse bind pose so as to make their influence only
how much they changed from their original positions relative to the origin
of the mesh.</p>
<p>Let&#39;s make a small example. We&#39;ll animate in 2d a grid like this</p>
<div class="webgl_center"><img src="resources/skinned-mesh.svg" style="width: 400px;"></div>

<ul>
<li>Where <code>b0</code>, <code>b1</code>, and <code>b2</code> are the bone matrices.</li>
<li><code>b1</code> is a child of <code>b0</code> and <code>b2</code> is a child of <code>b1</code></li>
<li>Verts <code>0,1</code> will get a weight of 1.0 from bone b0</li>
<li>Verts <code>2,3</code> will get a weight of 0.5 from bones b0 and b1</li>
<li>Verts <code>4,5</code> will get a weight of 1.0 from bone b1</li>
<li>Verts <code>6,7</code> will get a weight of 0.5 from bones b1 and b2</li>
<li>Verts <code>8,9</code> will get a weight of 1.0 from bone b3</li>
</ul>
<p>We&#39;ll use the library described in <a href="webgl-less-code-more-fun.html">less code more fun</a>.</p>
<p>First we need the vertices and for each vertex the index
of each bone that influences it and a number from 0 to 1
of how much influence that bone has.</p>
<pre><code>const arrays = {
  position: {
    numComponents: 2,
    data: [
    0,  1,  // 0
    0, -1,  // 1
    2,  1,  // 2
    2, -1,  // 3
    4,  1,  // 4
    4, -1,  // 5
    6,  1,  // 6
    6, -1,  // 7
    8,  1,  // 8
    8, -1,  // 9
    ],
  },
  boneNdx: {
    numComponents: 4,
    data: new Uint8Array([
      0, 0, 0, 0,  // 0
      0, 0, 0, 0,  // 1
      0, 1, 0, 0,  // 2
      0, 1, 0, 0,  // 3
      1, 0, 0, 0,  // 4
      1, 0, 0, 0,  // 5
      1, 2, 0, 0,  // 6
      1, 2, 0, 0,  // 7
      2, 0, 0, 0,  // 8
      2, 0, 0, 0,  // 9
    ]),
  },
  weight: {
    numComponents: 4,
    data: [
    1, 0, 0, 0,  // 0
    1, 0, 0, 0,  // 1
    .5,.5, 0, 0,  // 2
    .5,.5, 0, 0,  // 3
    1, 0, 0, 0,  // 4
    1, 0, 0, 0,  // 5
    .5,.5, 0, 0,  // 6
    .5,.5, 0, 0,  // 7
    1, 0, 0, 0,  // 8
    1, 0, 0, 0,  // 9
    ],
  },

  indices: {
    numComponents: 2,
    data: [
      0, 1,
      0, 2,
      1, 3,
      2, 3, //
      2, 4,
      3, 5,
      4, 5,
      4, 6,
      5, 7, //
      6, 7,
      6, 8,
      7, 9,
      8, 9,
    ],
  },
};
// calls gl.createBuffer, gl.bindBuffer, gl.bufferData
const bufferInfo = twgl.createBufferInfoFromArrays(gl, arrays);
const skinVAO = twgl.createVAOFromBufferInfo(gl, programInfo, bufferInfo);
</code></pre><p>We can define our uniform values including a matrix for each bone</p>
<pre><code>// 4 matrices, one for each bone
const numBones = 4;
const boneArray = new Float32Array(numBones * 16);

var uniforms = {
  projection: m4.orthographic(-20, 20, -10, 10, -1, 1),
  view: m4.translation(-6, 0, 0),
  bones: boneArray,
  color: [1, 0, 0, 1],
};
</code></pre><p>We can make views into the boneArray, one for each matrix</p>
<pre><code>// make views for each bone. This lets all the bones
// exist in 1 array for uploading but as separate
// arrays for using with the math functions
const boneMatrices = [];  // the uniform data
const bones = [];         // the value before multiplying by inverse bind matrix
const bindPose = [];      // the bind matrix
for (let i = 0; i &lt; numBones; ++i) {
  boneMatrices.push(new Float32Array(boneArray.buffer, i * 4 * 16, 16));
  bindPose.push(m4.identity());  // just allocate storage
  bones.push(m4.identity());     // just allocate storage
}
</code></pre><p>And then some code to manipulate the bone matrixes. We&#39;ll just rotate
them in a heirarchy like the bones of a finger.</p>
<pre><code>// rotate each bone by angle and simulate a hierarchy
function computeBoneMatrices(bones, angle) {
  comnst m = m4.identity();
  m4.zRotate(m, angle, bones[0]);
  m4.translate(bones[0], 4, 0, 0, m);
  m4.zRotate(m, angle, bones[1]);
  m4.translate(bones[1], 4, 0, 0, m);
  m4.zRotate(m, angle, bones[2]);
  // bones[3] is not used
}
</code></pre><p>Now call it once to generate their initial positions and use the result
to compute the inverse bind pose matrices.</p>
<pre><code>// compute the initial positions of each matrix
computeBoneMatrices(bindPose, 0);

// compute their inverses
const bindPoseInv = bindPose.map(function(m) {
  return m4.inverse(m);
});
</code></pre><p>Now we&#39;re ready to render</p>
<p>First we animate the bones, conmputing a new world matrix for each</p>
<pre><code>const t = time * 0.001;
const angle = Math.sin(t) * 0.8;
computeBoneMatrices(bones, angle);
</code></pre><p>Then we multiple the result of each by the inverse bind pose to deal with
the issue mentioned above</p>
<pre><code>// multiply each by its bindPoseInverse
bones.forEach((bone, ndx) =&gt; {
  m4.multiply(bone, bindPoseInv[ndx], boneMatrices[ndx]);
});
</code></pre><p>Then all the normal stuff, setting up the attributes, setting the uniforms, and drawing.</p>
<pre><code>gl.useProgram(programInfo.program);

gl.bindVertexArray(skinVAO);

// calls gl.uniformXXX, gl.activeTexture, gl.bindTexture
twgl.setUniforms(programInfo, uniforms);

// calls gl.drawArrays or gl.drawIndices
twgl.drawBufferInfo(gl, bufferInfo, gl.LINES);
</code></pre><p>And here&#39;s the result</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-skinning.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-skinning.html" target="_blank">click here to open in a separate window</a>
</div>

</p>
<p>The red lines are the <em>skinned</em> mesh.  The green and blue lines represent
the x-axis and y-axis of each bone or &quot;joint&quot;. You can see how the vertices
that are influenced by multiple bones move between the bones that influence
them. We didn&#39;t cover how the bones are drawn as it&#39;s not important to
explaining how skinning works. See the code if you&#39;re curious.</p>
<p>NOTE: bones vs joints is confusing. There&#39;s only 1 thing, <em>matrices</em>.
But, in a 3d modelling package they usually draw a gizmo (a ui widget)
between each matrix. That looks ends up looking like a bone. The joints
are where matrices are and they draw a line or cone from each joint
to the next to make it kind of look like a skeleton.</p>
<div class="webgl_center">
  <img src="resources/bone-display.png" style="width: 351px;">
  <div class="caption"><a href="https://www.blendswap.com/blends/view/66412">LowPoly Man</a> by <a href="https://www.blendswap.com/user/TiZeta">TiZeta</a></div>
</div>

<p>One thing to note that we might not have done before, we made a <code>uvec4</code> attribute which is an attribute that receives unsigned integers. If we were not using twgl
we&#39;d have to call <code>gl.vertexAttribIPointer</code> to set it up instead of the more
common <code>gl.vertexAttibPointer</code>. </p>
<p>Unfortunately there&#39;s a limit to the number of uniforms you can use in a shader.
The lower limit on WebGL is 64 vec4s which is only 8 mat4s and you probably
need some of those uniforms for other things like for example we have <code>color</code>
in the fragment shader and we have <code>projection</code> and <code>view</code> which means if
we were on a device with a limit of 64 vec4s we could only have 5 bones! Checking
<a href="https://webglstats.com/webgl/parameter/MAX_VERTEX_UNIFORM_VECTORS">WebGLStats</a>
most devices support 128 vec4s and 70% of them support 256 vec4s but with
are sample above that&#39;s still only 13 bones and 29 bones respectively. 13 is
not even enough for a early 90s Virtua Fighter 1 style character and 29 is not
close to the number used in most modern games.</p>
<p>A couple ways around that. One is to pre-process the models offline and break them
into multiple parts each one using no more than N bones. That&#39;s pretty complicated
and brings it&#39;s own set of issues.</p>
<p>Another is to store the bone matrices in a texture. This is an important reminder
that textures are not just images, they are effectively 2D arrays of random access
data that you can pass to a shader and you can use them for all kinds of things
that are not just reading images for texturing.</p>
<p>Let&#39;s pass our matrices in a texture to bypass the uniform limit. To make this
easy we&#39;re going to use floating point textures. </p>
<p>Let&#39;s update the shader to get the matrices out of a texture.
We&#39;ll make the texture have one matrix per row. Each texel of the texture
has R, G, B, and A, that&#39;s 4 values so we only need 4 pixels per matrix,
one pixel for each row of the matrix.
Textures can usually be at least 2048 pixels in certain dimension so
this will give us room for at least 2048 bone matrices which is plenty.</p>
<pre><code>in vec4 a_position;
in vec4 a_weight;
in uvec4 a_boneNdx;

uniform mat4 projection;
uniform mat4 view;
*uniform sampler2D boneMatrixTexture;

+mat4 getBoneMatrix(uint boneNdx) {
+  return mat4(
+    texelFetch(boneMatrixTexture, ivec2(0, boneNdx), 0),
+    texelFetch(boneMatrixTexture, ivec2(1, boneNdx), 0),
+    texelFetch(boneMatrixTexture, ivec2(2, boneNdx), 0),
+    texelFetch(boneMatrixTexture, ivec2(3, boneNdx), 0));
+}

void main() {

  gl_Position = projection * view *
*                (getBoneMatrix(a_boneNdx[0]) * a_position * a_weight[0] +
*                 getBoneMatrix(a_boneNdx[1]) * a_position * a_weight[1] +
*                 getBoneMatrix(a_boneNdx[2]) * a_position * a_weight[2] +
*                 getBoneMatrix(a_boneNdx[3]) * a_position * a_weight[3]);

}
</code></pre><p>Notice we&#39;re using <code>texelFetch</code> instead of <code>texture</code> to get data from
the texture. <code>texelFetch</code> retrieves a single texel from the texture.
It takes as input a, sampler, an ivec2 with the x,y coordinate of the texture
in texels, and the mip level as in</p>
<pre><code>vec4 data = texelFetch(sampler2D, ivec2(x, y), lod);
</code></pre><p>Now we&#39;ll setup a texture we can put the bone matrices in</p>
<pre><code>// prepare the texture for bone matrices
const boneMatrixTexture = gl.createTexture();
gl.bindTexture(gl.TEXTURE_2D, boneMatrixTexture);
// since we want to use the texture for pure data we turn
// off filtering
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
</code></pre><p>And we&#39;ll pass that texture as a uniform.</p>
<pre><code>const uniforms = {
  projection: m4.orthographic(-20, 20, -10, 10, -1, 1),
  view: m4.translation(-6, 0, 0),
*  boneMatrixTexture,
  color: [1, 0, 0, 1],
};
</code></pre><p>Then the only thing we need to change is to update the texture with the
latest bone matrices when rendering</p>
<pre><code>// update the texture with the current matrices
gl.bindTexture(gl.TEXTURE_2D, boneMatrixTexture);
gl.texImage2D(
    gl.TEXTURE_2D,
    0,         // level
    gl.RGBA32, // internal format
    4,         // width 4 pixels, each pixel has RGBA so 4 pixels is 16 values
    numBones,  // one row per bone
    0,         // border
    gl.RGBA,   // format
    gl.FLOAT,  // type
    boneArray);
</code></pre><p>The result it the same but we&#39;ve solved the issue that there aren&#39;t
enough uniforms to pass in the matrices via uniforms.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-skinning-bone-matrices-in-texture.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-skinning-bone-matrices-in-texture.html" target="_blank">click here to open in a separate window</a>
</div>

</p>
<p>So that&#39;s the basics of skinning. It&#39;s not so hard to write the code to display
a skinned mesh. The harder part is actually getting data. You generally need
some 3D software like blender/maya/3d studio max, and then to either write
your own exporter or find a an exporter and format that will provide all the data needed.
The vertices, their bones, which bones influence which vertices and their influence
weights,</p>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgl/lessons/webgl-skinning.html" selected>English</a>
    <option value="/webgl/lessons/de/webgl-skinning.html" >Deutsch</a>
    <option value="/webgl/lessons/ko/webgl-skinning.html" >한국어</a>
    <option value="/webgl/lessons/pt-br/webgl-skinning.html" >Português Brasileiro</a>
</select>


        <div id="toc">
          <ul>
  <li>Fundamentals</li>
  <ul>
    <li><a href="/webgl/lessons/webgl-getting-webgl2.html">How to use WebGL2</a></li>
    <li><a href="/webgl/lessons/webgl-fundamentals.html">WebGL2 Fundamentals</a></li>
    <li><a href="/webgl/lessons/webgl-how-it-works.html">WebGL2 How It Works</a></li>
    <li><a href="/webgl/lessons/webgl-shaders-and-glsl.html">WebGL2 Shaders and GLSL</a></li>
  </ul>
  <li>WebGL2 vs WebGL1</li>
  <ul>
    <li><a href="/webgl/lessons/webgl2-whats-new.html">What's new in WebGL2</a></li>
    <li><a href="/webgl/lessons/webgl1-to-webgl2.html">Moving from WebGL1 to WebGL2</a></li>
    <li><a href="/webgl/lessons/webgl1-to-webgl2-fundamentals.html">Differences from WebGLFundamentals.org to WebGL2Fundamentals.org</a></li>
  </ul>
  <li>Image Processing</li>
  <ul>
    <li><a href="/webgl/lessons/webgl-image-processing.html">WebGL2 Image Processing</a></li>
    <li><a href="/webgl/lessons/webgl-image-processing-continued.html">WebGL2 Image Processing Continued</a></li>
  </ul>
  <li>2D translation, rotation, scale, matrix math</li>
  <ul>
    <li><a href="/webgl/lessons/webgl-2d-translation.html">WebGL2 2D Translation</a></li>
    <li><a href="/webgl/lessons/webgl-2d-rotation.html">WebGL2 2D Rotation</a></li>
    <li><a href="/webgl/lessons/webgl-2d-scale.html">WebGL2 2D Scale</a></li>
    <li><a href="/webgl/lessons/webgl-2d-matrices.html">WebGL2 2D Matrices</a></li>
  </ul>
  <li>3D</li>
  <ul>
    <li><a href="/webgl/lessons/webgl-3d-orthographic.html">WebGL2 - Orthographic 3D</a></li>
    <li><a href="/webgl/lessons/webgl-3d-perspective.html">WebGL2 3D Perspective</a></li>
    <li><a href="/webgl/lessons/webgl-3d-camera.html">WebGL2 3D - Cameras</a></li>
    <li><a href="/webgl/lessons/webgl-matrix-naming.html">WebGL2 3D - Matrix Naming</a></li>
  </ul>
  <li>Lighting</li>
  <ul>
    <li><a href="/webgl/lessons/webgl-3d-lighting-directional.html">WebGL2 3D - Directional Lighting</a></li>
    <li><a href="/webgl/lessons/webgl-3d-lighting-point.html">WebGL2 3D - Point Lighting</a></li>
    <li><a href="/webgl/lessons/webgl-3d-lighting-spot.html">WebGL2 3D - Spot Lighting</a></li>
  </ul>
  <li>Structure and Organization</li>
  <ul>
    <li><a href="/webgl/lessons/webgl-less-code-more-fun.html">WebGL2 - Less Code, More Fun</a></li>
    <li><a href="/webgl/lessons/webgl-drawing-multiple-things.html">WebGL2 - Drawing Multiple Things</a></li>
    <li><a href="/webgl/lessons/webgl-scene-graph.html">WebGL2 - Scene Graphs</a></li>
  </ul>
  <li>Geometry</li>
  <ul>
    <li><a href="/webgl/lessons/webgl-3d-geometry-lathe.html">WebGL2 3D Geometry - Lathe</a></li>
  </ul>
  <li>Textures</li>
  <ul>
    <li><a href="/webgl/lessons/webgl-3d-textures.html">WebGL2 3D - Textures</a></li>
    <li><a href="/webgl/lessons/webgl-data-textures.html">WebGL2 - Data Textures</a></li>
    <li><a href="/webgl/lessons/webgl-2-textures.html">WebGL2 - Using 2 or More Textures</a></li>
    <li><a href="/webgl/lessons/webgl-cors-permission.html">WebGL2 - Cross Origin Images</a></li>
    <li><a href="/webgl/lessons/webgl-3d-perspective-correct-texturemapping.html">WebGL2 3D - Perspective Correct Texture Mapping</a></li>
  </ul>
  <li>Rendering To A Texture</li>
  <ul>
    <li><a href="/webgl/lessons/webgl-render-to-texture.html">WebGL2 - Render to Texture</a></li>
  </ul>
  </li>
  <li>Techniques</li>
  <ul>
    <li>2D</li>
    <ul>
      <li><a href="/webgl/lessons/webgl-2d-drawimage.html">WebGL2 2D - DrawImage</a>
      <li><a href="/webgl/lessons/webgl-2d-matrix-stack.html">WebGL2 2D - Matrix Stack</a>
    </ul>
    <li>3D</li>
    <ul>
      <li><a href="/webgl/lessons/webgl-skinning.html">WebGL2 - Skinning</a>
    </ul>
    <li>Text</li>
    <ul>
      <li><a href="/webgl/lessons/webgl-text-html.html">WebGL2 Text - HTML</a>
      <li><a href="/webgl/lessons/webgl-text-canvas2d.html">WebGL2 Text - Canvas 2D</a>
      <li><a href="/webgl/lessons/webgl-text-texture.html">WebGL2 Text - Using a Texture</a>
      <li><a href="/webgl/lessons/webgl-text-glyphs.html">WebGL2 Text - Using a Glyph Texture</a>
    </ul>
  </ul>
  <li>Misc</li>
  <ul>
    <li><a href="/webgl/lessons/webgl-setup-and-installation.html">WebGL2 Setup And Installation</a></li>
    <li><a href="/webgl/lessons/webgl-boilerplate.html">WebGL2 Boilerplate</a></li>
    <li><a href="/webgl/lessons/webgl-resizing-the-canvas.html">WebGL2 Resizing the Canvas</a></li>
    <li><a href="/webgl/lessons/webgl-animation.html">WebGL2 - Animation</a></li>
    <li><a href="/webgl/lessons/webgl-and-alpha.html">WebGL2 and Alpha</a></li>
    <li><a href="/webgl/lessons/webgl-2d-vs-3d-library.html">WebGL2 - 2D vs 3D libraries</a></li>
    <li><a href="/webgl/lessons/webgl-anti-patterns.html">WebGL2 - Anti-Patterns</a></li>
  </ul>
</ul>
<ul>
  <li><a href="/docs/">Helper API Docs</a></li>
  <li><a href="http://twgljs.org">TWGL, A tiny WebGL helper library</a></li>
  <li><a href="https://github.com/greggman/webgl2-fundamentals">github</a></li>
</ul>

        </div>
    </div>
    <div class="lesson-comments">
        <div>Questions? <a href="http://stackoverflow.com/questions/tagged/webgl2">Ask on stackoverflow</a>.</div>
        <div>Issue/Bug? <a href="http://github.com/greggman/webgl2-fundamentals/issues">Create an issue on github</a>.</div>

        <div id="disqus_thread"></div>
        <script type="text/javascript">
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'webgl2fundamentals'; // required: replace example with your forum shortname
            var disqus_identifier = 'WebGL Skinning';
            var disqus_title = 'WebGL Skinning';

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function() {
                if (window.location.hostname.indexOf("webgl2fundamentals.org") < 0) {
                    return;
                }
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>
</body>
<script src="/3rdparty/jquery-1.11.2.min.js"></script>
<script src="/webgl/lessons/resources/prettify.js"></script>
<script src="/webgl/lessons/resources/lesson.js"></script>
<script src="//cdn.webglstats.com/stat.js" defer="defer" async="async"></script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-90754717-1', 'auto');
  ga('send', 'pageview');

</script>


</html>



