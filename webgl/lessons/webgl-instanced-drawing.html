<!DOCTYPE html>
<!-- this file is auto-generated from webgl/lessons/webgl-instanced-drawing.md. Do not edited directly -->
<!--
Copyright 2012, Gregg Tavares.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

*   Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

*   Redistributions in binary form must reproduce the above
    copyright notice, this list of conditions and the following disclaimer
    in the documentation and/or other materials provided with the
    distribution.

*   Neither the name of Gregg Tavares. nor the names of his
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<meta property="og:title" content="WebGL Optimization - Instanced Drawing" />
<meta property="og:type" content="website" />
<meta property="og:image" content="https://webgl2fundamentals.org/webgl/lessons/resources/webgl2fundamentals.jpg" />
<meta property="og:description" content="Drawing Multiple Instances of the same Object" />
<meta property="og:url" content="https://webgl2fundamentals.org/webgl/lessons/webgl-instanced-drawing.html" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:site" content="@greggman" />
<meta name="twitter:creator" content="@greggman" />
<meta name="twitter:domain" content="webgl2fundamentals.org" />
<meta name="twitter:title" content="WebGL Optimization - Instanced Drawing" />
<meta name="twitter:url" content="https://webgl2fundamentals.org/webgl/lessons/webgl-instanced-drawing.html" />
<meta name="twitter:description" content="Drawing Multiple Instances of the same Object" />
<meta name="twitter:image:src" content="https://webgl2fundamentals.org/webgl/lessons/resources/webgl2fundamentals.jpg" />


<title>WebGL Optimization - Instanced Drawing</title>
<link href="/webgl/lessons/resources/webgl2fundamentals-icon.png" rel="shortcut icon" type="image/png">
<link rel="stylesheet" href="/webgl/lessons/resources/lesson.css" type="text/css" />
</head>
<body>
<div class="webgl_navbar">
  <div>
    <select class="language">
    <option value="/webgl/lessons/webgl-instanced-drawing.html" selected>English</a>
    <option value="/webgl/lessons/de/webgl-instanced-drawing.html" >Deutsch</a>
    <option value="/webgl/lessons/ko/webgl-instanced-drawing.html" >한국어</a>
    <option value="/webgl/lessons/pt-br/webgl-instanced-drawing.html" >Português Brasileiro</a>
    <option value="/webgl/lessons/zh_cn/webgl-instanced-drawing.html" >简体中文</a>
</select>


    <a href="#toc">Table of Contents</a>
  </div>
</div>
<div class="webgl_header">
  <h1><a href="/">WebGL2Fundamentals.org</a></h1>
</div>


<div class="container">
  <div class="lesson-title">
    <h1>WebGL Optimization - Instanced Drawing</h1>
  </div>
  <div class="lesson">
    <div class="lesson-main">
      <p>WebGL has a feature called <em>instanced drawing</em>.
It is basically a way to draw more than one of the
same thing faster than drawing each thing individually.</p>
<p>First let&#39;s make an example that runs multiple instances of the
same thing.</p>
<p>Starting with code <em>similar</em> to what we ended up with at
the end of <a href="webgl-3d-orthographic.html">the article on orthographic projection</a>
we start with these 2 shaders</p>
<pre class="prettyprint"><code class="lang-js">const vertexShaderSource = `#version 300 es
in vec4 a_position;
uniform mat4 matrix;

out vec4 v_color;

void main() {
  // Multiply the position by the matrix.
  gl_Position = matrix * a_position;
}
`;

const fragmentShaderSource = `#version 300 es
precision mediump float;

uniform vec4 color;

out vec4 outColor;

void main() {
  outColor = color;
}
`;
</code></pre>
<p>The vertex shader multiplies each vertex by a single matrix which we
covered in <a href="webgl-3d-orthographic.html">that article</a> is
a fairly flexible arrangement. The fragment shader just uses
a color we pass in via a uniform.</p>
<p>To draw them we need compile the shaders, link them together
and look up the locations of the attributes and uniforms</p>
<pre class="prettyprint"><code class="lang-js">const program = webglUtils.createProgramFromSources(gl,
    [vertexShaderSource, fragmentShaderSource]);

const positionLoc = gl.getAttribLocation(program, &#39;a_position&#39;);
const colorLoc = gl.getUniformLocation(program, &#39;color&#39;);
const matrixLoc = gl.getUniformLocation(program, &#39;matrix&#39;);
</code></pre>
<p>and make a vertex array object to hold attribute state</p>
<pre class="prettyprint"><code class="lang-js">// Create a vertex array object (attribute state)
const vao = gl.createVertexArray();

// and make it the one we&#39;re currently working with
gl.bindVertexArray(vao);
</code></pre>
<p>Then we need to supply data for the positions via a buffer</p>
<pre class="prettyprint"><code class="lang-js">const positionBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
    -0.1,  0.4,
    -0.1, -0.4,
     0.1, -0.4,
     0.1, -0.4,
    -0.1,  0.4,
     0.1,  0.4,
     0.4, -0.1,
    -0.4, -0.1,
    -0.4,  0.1,
    -0.4,  0.1,
     0.4, -0.1,
     0.4,  0.1,
  ]), gl.STATIC_DRAW);
const numVertices = 12;

// setup the position attribute
gl.enableVertexAttribArray(positionLoc);
gl.vertexAttribPointer(
    positionLoc,  // location
    2,            // size (num values to pull from buffer per iteration)
    gl.FLOAT,     // type of data in buffer
    false,        // normalize
    0,            // stride (0 = compute from size and type above)
    0,            // offset in buffer
);
</code></pre>
<p>Let&#39;s draw 5 instances. We&#39;ll make 5 matrixes and 5 colors for
each instance</p>
<pre class="prettyprint"><code class="lang-js">const numInstances = 5;
const matrices = [
  m4.identity(),
  m4.identity(),
  m4.identity(),
  m4.identity(),
  m4.identity(),
];

const colors = [
  [ 1, 0, 0, 1, ],  // red
  [ 0, 1, 0, 1, ],  // green
  [ 0, 0, 1, 1, ],  // blue
  [ 1, 0, 1, 1, ],  // magenta
  [ 0, 1, 1, 1, ],  // cyan
];
</code></pre>
<p>To draw use the shader program, setup the attribute,
then loop over the 5 instances, computing a new matrix
for each one, setting the matrix uniform and color
and then drawing.</p>
<pre class="prettyprint"><code class="lang-js">function render(time) {
  time *= 0.001; // seconds

  webglUtils.resizeCanvasToDisplaySize(gl.canvas);

  // Tell WebGL how to convert from clip space to pixels
  gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

  gl.useProgram(program);

  // setup all attributes
  gl.bindVertexArray(vao);

  matrices.forEach((mat, ndx) =&gt; {
    m4.translation(-0.5 + ndx * 0.25, 0, 0, mat);
    m4.zRotate(mat, time * (0.1 + 0.1 * ndx), mat);

    const color = colors[ndx];

    gl.uniform4fv(colorLoc, color);
    gl.uniformMatrix4fv(matrixLoc, false, mat);

    gl.drawArrays(
        gl.TRIANGLES,
        0,             // offset
        numVertices,   // num vertices per instance
    );
  });

  requestAnimationFrame(render);
}
requestAnimationFrame(render);
</code></pre>
<p>Note that the matrix math library takes an optional destination
matrix at the end of each matrix math function. In the past we
haven&#39;t used this feature and just let the library allocate a new
matrix for us but this time we want the result to be stored
in the matrices we already created.</p>
<p>This works and we get 5 plus symbols of different colors rotating.</p>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-instanced-drawing-not-instanced.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-instanced-drawing-not-instanced.html" target="_blank">click here to open in a separate window</a>
</div>

</p>
<p>That took 5 calls each to <code>gl.uniform4v</code>, <code>gl.uniformMatrix4fv</code>,
and <code>gl.drawArrays</code> for a total of 15 WebGL calls. If our
shaders were more complex, like the shaders in
<a href="webgl-3d-lighting-spot.html">the article on spot lighting</a>
we&#39;d have at least 7 calls per object, 6 calls to <code>gl.uniformXXX</code>
and one call to <code>gl.drawArrays</code>. If we were drawing 400 objects
that would be 2800 WebGL calls.</p>
<p>Instancing is a way to reduce those calls. It works by
letting you tell WebGL how many times you want the same
thing drawn (the number of instances). For each attribute
you designate if that attribute will advance to the <em>next value</em>
from its assigned buffer every time the vertex shader is
called (the default), or only every N instances where N is usually
1.</p>
<p>So for example instead of supplying <code>matrix</code> and <code>color</code>
from a uniform, we would instead supply them via an <code>attribute</code>.
We&#39;d put the matrix and color for each instance in a buffer,
set up the attributes to pull data from those buffers, and
tell WebGL, only advance to the next value once per instance.</p>
<p>Let&#39;s do it!</p>
<p>First we&#39;ll change the shaders to use attributes for <code>matrix</code>
and <code>color</code> instead of uniforms.</p>
<pre class="prettyprint"><code class="lang-js">const vertexShaderSource = `#version 300 es
in vec4 a_position;
-uniform mat4 matrix;
+in vec4 color;
+in mat4 matrix;
+
+out vec4 v_color;

void main() {
  // Multiply the position by the matrix.
  gl_Position = matrix * a_position;

+  // Pass the vertex color to the fragment shader.
+  v_color = color;
}
`;
</code></pre>
<p>and </p>
<pre class="prettyprint"><code class="lang-js">const fragmentShaderSource = `#version 300 es
precision mediump float;

-uniform vec4 color;
+// Passed in from the vertex shader.
+in vec4 v_color;

void main() {
-  gl_FragColor = color;
+  gl_FragColor = v_color;
}
`;
</code></pre>
<p>attributes only work in the vertex shader do we need to
get the color from an attribute in the vertex shader
and pass it to the fragment shader.</p>
<p>Next we need to look up the locations of these attributes</p>
<pre class="prettyprint"><code class="lang-js">const program = webglUtils.createProgramFromSources(gl,
    [vertexShaderSource, fragmentShaderSource]);

const positionLoc = gl.getAttribLocation(program, &#39;a_position&#39;);
-const colorLoc = gl.getUniformLocation(program, &#39;color&#39;);
-const matrixLoc = gl.getUniformLocation(program, &#39;matrix&#39;);
+const colorLoc = gl.getAttribLocation(program, &#39;color&#39;);
+const matrixLoc = gl.getAttribLocation(program, &#39;matrix&#39;);
</code></pre>
<p>Now, we need a buffer hold the matrices at will get applied
to the attribute. Since a buffer is best updated in one
<em>chuck</em> we&#39;ll put all of our matrices in the same <code>Float32Array</code></p>
<pre class="prettyprint"><code class="lang-js">// setup matrixes, one per instance
const numInstances = 5;
+// make a typed array with one view per matrix
+const matrixData = new Float32Array(numInstances * 16);
</code></pre>
<p>We&#39;ll then make <code>Float32Array</code> views, one for each matrix.</p>
<pre class="prettyprint"><code class="lang-js">-const matrices = [
-  m4.identity(),
-  m4.identity(),
-  m4.identity(),
-  m4.identity(),
-  m4.identity(),
-];
const matrices = [];
for (let i = 0; i &lt; numInstances; ++i) {
  const byteOffsetToMatrix = i * 16 * 4;
  const numFloatsForView = 16;
  matrices.push(new Float32Array(
      matrixData.buffer,
      byteOffsetToMatrix,
      numFloatsForView));
}
</code></pre>
<p>This way when we want to reference the data for all the matrixes
we can use <code>matrixData</code> but when we want any individual matrix
we can use <code>matrices[ndx]</code>.</p>
<p>We also need to create a buffer on the GPU for this data.
We only need to allocate the buffer at this point, we don&#39;t
need to supply data so the 2nd parameter to <code>gl.bufferData</code>
is a size which just allocates the buffer.</p>
<pre class="prettyprint"><code class="lang-js">const matrixBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, matrixBuffer);
// just allocate the buffer
gl.bufferData(gl.ARRAY_BUFFER, matrixData.byteLength, gl.DYNAMIC_DRAW);
</code></pre>
<p>Notice we passed <code>gl.DYNAMIC_DRAW</code> as the last parameter. This is a <em>hint</em>
to WebGL that we&#39;re going to change this data often.</p>
<p>Now we need to set up the attributes for the matrices.
The matrix attribute is a <code>mat4</code>. A <code>mat4</code> actually uses
4 consecutive attribute slots.</p>
<pre class="prettyprint"><code class="lang-js">const bytesPerMatrix = 4 * 16;
for (let i = 0; i &lt; 4; ++i) {
  const loc = matrixLoc + i;
  gl.enableVertexAttribArray(loc);
  // note the stride and offset
  const offset = i * 16;  // 4 floats per row, 4 bytes per float
  gl.vertexAttribPointer(
      loc,              // location
      4,                // size (num values to pull from buffer per iteration)
      gl.FLOAT,         // type of data in buffer
      false,            // normalize
      bytesPerMatrix,   // stride, num bytes to advance to get to next set of values
      offset,           // offset in buffer
  );
  // this line says this attribute only changes for each 1 instance
  gl.vertexAttribDivisor(loc, 1);
}
</code></pre>
<p>The most important point relative to instanced drawing is
the call to <code>gl.vertexAttribDivisor</code>. It sets this
attribute to only advance to the next value once per instance.
This means the <code>matrix</code> attributes will use the first matrix for
every vertex for the first instance, the second matrix for the
second instance and so on.</p>
<p>Next we need our colors also in a buffer. This data will not
be changing, at least in this example, so we&#39;ll just upload
the data.</p>
<pre class="prettyprint"><code class="lang-js">-const colors = [
-  [ 1, 0, 0, 1, ],  // red
-  [ 0, 1, 0, 1, ],  // green
-  [ 0, 0, 1, 1, ],  // blue
-  [ 1, 0, 1, 1, ],  // magenta
-  [ 0, 1, 1, 1, ],  // cyan
-];
+// setup colors, one per instance
+const colorBuffer = gl.createBuffer();
+gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
+gl.bufferData(gl.ARRAY_BUFFER,
+    new Float32Array([
+        1, 0, 0, 1,  // red
+        0, 1, 0, 1,  // green
+        0, 0, 1, 1,  // blue
+        1, 0, 1, 1,  // magenta
+        0, 1, 1, 1,  // cyan
+      ]),
+    gl.STATIC_DRAW);
</code></pre>
<p>We also need to setup the color attribute</p>
<pre class="prettyprint"><code class="lang-js">// set attribute for color
gl.enableVertexAttribArray(colorLoc);
gl.vertexAttribPointer(colorLoc, 4, gl.FLOAT, false, 0, 0);
// this line says this attribute only changes for each 1 instance
gl.vertexAttribDivisor(colorLoc, 1);
</code></pre>
<p>At draw time instead of looping over each instance,
setting the matrix and color uniforms, and then calling draw
we&#39;ll first compute the matrix for each instance.</p>
<pre class="prettyprint"><code class="lang-js">// update all the matrices
matrices.forEach((mat, ndx) =&gt; {
  m4.translation(-0.5 + ndx * 0.25, 0, 0, mat);
  m4.zRotate(mat, time * (0.1 + 0.1 * ndx), mat);

-  const color = colors[ndx];
-
-  gl.uniform4fv(colorLoc, color);
-  gl.uniformMatrix4fv(matrixLoc, false, mat);
-
-  gl.drawArrays(
-      gl.TRIANGLES,
-      0,             // offset
-      numVertices,   // num vertices per instance
-  );
});
</code></pre>
<p>Because our matrix library takes an optional destination matrix
and because our matrices are just <code>Float32Array</code> views into
the same larger <code>Float32Array</code>, when we&#39;re done all the matrix
data is ready to upload to the GPU directly.</p>
<pre class="prettyprint"><code class="lang-js">// upload the new matrix data
gl.bindBuffer(gl.ARRAY_BUFFER, matrixBuffer);
gl.bufferSubData(gl.ARRAY_BUFFER, 0, matrixData);
</code></pre>
<p>Finally we can draw all instances in a single draw call.</p>
<pre class="prettyprint"><code class="lang-js">gl.drawArraysInstanced(
  gl.TRIANGLES,
  0,             // offset
  numVertices,   // num vertices per instance
  numInstances,  // num instances
);
</code></pre>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-instanced-drawing.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-instanced-drawing.html" target="_blank">click here to open in a separate window</a>
</div>

</p>
<p>In the example above we had 3 WebGL calls per shape * 5 shapes
are 15 calls total. We now have just 2 calls for all 5 shapes,
one to upload the matrices, another to draw.</p>
<p>I feel like this should go without saying but I then again maybe
it&#39;s only obvious to me because I&#39;ve done this too much. The code
above does not take into account the aspect of the canvas.
It does not use a <a href="webgl-3d-orthographic.html">projection matrix</a>
or a <a href="webgl-3d-camera.html">view matrix</a>. It was meant only
to demonstrate instanced drawing. If you wanted a projection and/or
a view matrix the most obvious way to add them would be to add
one or two more uniforms to the vertex shader.</p>
<pre class="prettyprint"><code class="lang-js">const vertexShaderSource = `#version 300 es
in vec4 a_position;
in vec4 color;
in mat4 matrix;
+uniform mat4 projection;
+uniform mat4 view;

out vec4 v_color;

void main() {
  // Multiply the position by the matrix.
-  gl_Position = matrix * a_position;
+  gl_Position = projection * view * matrix * a_position;

  // Pass the vertex color to the fragment shader.
  v_color = color;
}
`;
</code></pre>
<p>and then look up their locations at init time</p>
<pre class="prettyprint"><code class="lang-js">const positionLoc = gl.getAttribLocation(program, &#39;a_position&#39;);
const colorLoc = gl.getAttribLocation(program, &#39;color&#39;);
const matrixLoc = gl.getAttribLocation(program, &#39;matrix&#39;);
+const projectionLoc = gl.getUniformLocation(program, &#39;projection&#39;);
+const viewLoc = gl.getUniformLocation(program, &#39;view&#39;);
</code></pre>
<p>and set them appropriately at render time.</p>
<pre class="prettyprint"><code class="lang-js">gl.useProgram(program);

+// set the view and projection matrices since
+// they are shared by all instances
+const aspect = gl.canvas.clientWidth / gl.canvas.clientHeight;
+gl.uniformMatrix4fv(projectionLoc, false,
+    m4.orthographic(-aspect, aspect, -1, 1, -1, 1));
+gl.uniformMatrix4fv(viewLoc, false, m4.zRotation(time * .1));
</code></pre>
<p><div class="webgl_example_container">
  <iframe class="webgl_example" style=" " src="/webgl/resources/editor.html?url=/webgl/lessons/..%2Fwebgl-instanced-drawing-projection-view.html"></iframe>
  <a class="webgl_center" href="/webgl/lessons/../webgl-instanced-drawing-projection-view.html" target="_blank">click here to open in a separate window</a>
</div>

</p>

    </div>
    <div class="lesson-sidebar">
        <select class="language">
    <option value="/webgl/lessons/webgl-instanced-drawing.html" selected>English</a>
    <option value="/webgl/lessons/de/webgl-instanced-drawing.html" >Deutsch</a>
    <option value="/webgl/lessons/ko/webgl-instanced-drawing.html" >한국어</a>
    <option value="/webgl/lessons/pt-br/webgl-instanced-drawing.html" >Português Brasileiro</a>
    <option value="/webgl/lessons/zh_cn/webgl-instanced-drawing.html" >简体中文</a>
</select>


        <div id="toc">
          <ul>  <li>Fundamentals</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-getting-webgl2.html">How to use WebGL2</a></li>
<li><a href="/webgl/lessons/webgl-fundamentals.html">Fundamentals</a></li>
<li><a href="/webgl/lessons/webgl-how-it-works.html">How It Works</a></li>
<li><a href="/webgl/lessons/webgl-shaders-and-glsl.html">Shaders and GLSL</a></li>
        </ul>
  <li>WebGL2 vs WebGL1</li>
        <ul>
          <li><a href="/webgl/lessons/webgl2-whats-new.html">What's new in WebGL2</a></li>
<li><a href="/webgl/lessons/webgl1-to-webgl2.html">Moving from WebGL1 to WebGL2</a></li>
<li><a href="/webgl/lessons/webgl1-to-webgl2-fundamentals.html">Differences from WebGLFundamentals.org to WebGL2Fundamentals.org</a></li>
        </ul>
  <li>Image Processing</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-image-processing.html">Image Processing</a></li>
<li><a href="/webgl/lessons/webgl-image-processing-continued.html">Image Processing Continued</a></li>
        </ul>
  <li>2D translation, rotation, scale, matrix math</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-2d-translation.html">2D Translation</a></li>
<li><a href="/webgl/lessons/webgl-2d-rotation.html">2D Rotation</a></li>
<li><a href="/webgl/lessons/webgl-2d-scale.html">2D Scale</a></li>
<li><a href="/webgl/lessons/webgl-2d-matrices.html">2D Matrices</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-3d-orthographic.html">Orthographic 3D</a></li>
<li><a href="/webgl/lessons/webgl-3d-perspective.html">WebGL2 3D Perspective</a></li>
<li><a href="/webgl/lessons/webgl-3d-camera.html">3D - Cameras</a></li>
<li><a href="/webgl/lessons/webgl-matrix-naming.html">3D - Matrix Naming</a></li>
        </ul>
  <li>Lighting</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-3d-lighting-directional.html">Directional Lighting</a></li>
<li><a href="/webgl/lessons/webgl-3d-lighting-point.html">Point Lighting</a></li>
<li><a href="/webgl/lessons/webgl-3d-lighting-spot.html">Spot Lighting</a></li>
        </ul>
  <li>Structure and Organization</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-less-code-more-fun.html">Less Code, More Fun</a></li>
<li><a href="/webgl/lessons/webgl-drawing-multiple-things.html">Drawing Multiple Things</a></li>
<li><a href="/webgl/lessons/webgl-scene-graph.html">Scene Graphs</a></li>
        </ul>
  <li>Geometry</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-3d-geometry-lathe.html">3D Geometry - Lathe</a></li>
        </ul>
  <li>Textures</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-3d-textures.html">Textures</a></li>
<li><a href="/webgl/lessons/webgl-data-textures.html">Data Textures</a></li>
<li><a href="/webgl/lessons/webgl-2-textures.html">Using 2 or More Textures</a></li>
<li><a href="/webgl/lessons/webgl-cors-permission.html">Cross Origin Images</a></li>
<li><a href="/webgl/lessons/webgl-3d-perspective-correct-texturemapping.html">Perspective Correct Texture Mapping</a></li>
<li><a href="/webgl/lessons/webgl-planar-projection-mapping.html">Planar and Perspective Projection Mapping</a></li>
        </ul>
  <li>Rendering To A Texture</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-render-to-texture.html">Render to Texture</a></li>
        </ul>
  <li>Shadows</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-shadows.html">Shadows</a></li>
        </ul>
  <li>Techniques</li>
        <ul>
            <li>2D</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-2d-drawimage.html">2D - DrawImage</a></li>
<li><a href="/webgl/lessons/webgl-2d-matrix-stack.html">2D - Matrix Stack</a></li>
        </ul>
  <li>3D</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-cube-maps.html">Cubemaps</a></li>
<li><a href="/webgl/lessons/webgl-environment-maps.html">Environment maps</a></li>
<li><a href="/webgl/lessons/webgl-skybox.html">Skyboxes</a></li>
<li><a href="/webgl/lessons/webgl-skinning.html">Skinning</a></li>
<li><a href="/webgl/lessons/webgl-fog.html">Fog</a></li>
        </ul>
  <li>Text</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-text-html.html">Text - HTML</a></li>
<li><a href="/webgl/lessons/webgl-text-canvas2d.html">Text - Canvas 2D</a></li>
<li><a href="/webgl/lessons/webgl-text-texture.html">Text - Using a Texture</a></li>
<li><a href="/webgl/lessons/webgl-text-glyphs.html">Text - Using a Glyph Texture</a></li>
        </ul>
        </ul>
  <li>Tips</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-smallest-programs.html">Smallest Programs</a></li>
<li><a href="/webgl/lessons/webgl-drawing-without-data.html">Drawing Without Data</a></li>
<li><a href="/webgl/lessons/webgl-pulling-vertices.html">Pulling Vertices</a></li>
        </ul>
  <li>Misc</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-setup-and-installation.html">Setup And Installation</a></li>
<li><a href="/webgl/lessons/webgl-boilerplate.html">Boilerplate</a></li>
<li><a href="/webgl/lessons/webgl-resizing-the-canvas.html">Resizing the Canvas</a></li>
<li><a href="/webgl/lessons/webgl-animation.html">Animation</a></li>
<li><a href="/webgl/lessons/webgl-points-lines-triangles.html">Points, Lines, and Triangles</a></li>
<li><a href="/webgl/lessons/webgl-indexed-vertices.html">Indexed Vertices (gl.drawElements)</a></li>
<li><a href="/webgl/lessons/webgl-instanced-drawing.html">Instanced Drawing</a></li>
<li><a href="/webgl/lessons/webgl-multiple-views.html">Multiple Views, Multiple Canvases</a></li>
<li><a href="/webgl/lessons/webgl-visualizing-the-camera.html">Visualizing the Camera</a></li>
<li><a href="/webgl/lessons/webgl-and-alpha.html">WebGL2 and Alpha</a></li>
<li><a href="/webgl/lessons/webgl-2d-vs-3d-library.html">2D vs 3D libraries</a></li>
<li><a href="/webgl/lessons/webgl-anti-patterns.html">Anti-Patterns</a></li>
<li><a href="/webgl/lessons/webgl-matrix-vs-math.html">WebGL Matrices vs Math Matrices</a></li>
        </ul>
  <li>Reference</li>
        <ul>
          <li><a href="/webgl/lessons/webgl-attributes.html">Attributes</a></li>
<li><a href="/webgl/lessons/webgl-texture-units.html">Texture Units</a></li>
        </ul></ul>
<ul>
  <li><a href="/docs/">Helper API Docs</a></li>
  <li><a href="http://twgljs.org">TWGL, A tiny WebGL helper library</a></li>
  <li><a href="https://github.com/gfxfundamentals/webgl2-fundamentals">github</a></li>
</ul>
        </div>
    </div>
    <div class="lesson-comments">
        <div>Questions? <a href="http://stackoverflow.com/questions/tagged/webgl2">Ask on stackoverflow</a>.</div>
        <div>Issue/Bug? <a href="http://github.com/gfxfundamentals/webgl2-fundamentals/issues">Create an issue on github</a>.</div>

        <div id="disqus_thread"></div>
        <script type="text/javascript">
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'webgl2fundamentals'; // required: replace example with your forum shortname
            var disqus_identifier = 'WebGL Optimization - Instanced Drawing';
            var disqus_title = 'WebGL Optimization - Instanced Drawing';

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function() {
                if (window.location.hostname.indexOf("webgl2fundamentals.org") < 0) {
                    return;
                }
                var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    </div>
  </div>
</div>
</body>
<script src="/3rdparty/jquery-1.11.2.min.js"></script>
<script src="/webgl/lessons/resources/prettify.js"></script>
<script src="/webgl/lessons/resources/lesson.js"></script>
<script src="//cdn.webglstats.com/stat.js" defer="defer" async="async"></script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-90754717-1', 'auto');
  ga('send', 'pageview');

</script>


</html>



